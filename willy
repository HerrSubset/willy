#!/usr/bin/env python

import argparse
import csv
import random
import os.path
from datetime import datetime



################################################################################
## Helper Functions
################################################################################

# print a line with information for the user
def print_info(message):
    print("[INFO] " + message)



# print an error line to the user
def die(message):
    print("[ERROR] " + message)
    exit()



#gets the path for the output file
def get_output_path(args, default_path = "willyWroteThis.csv"):
    path = default_path
    if args.output_file:
        path = args.output_file

    return path



# reads the input file and writes all lines into an array
def get_lines_array(args):
    print_info("First let me get all this stuff in my head.")
    with open(args.file, "r") as read_file:
        lines = read_file.readlines()

    return lines



# sorts an array of strings on a certain index
def get_user_hash(lines, index):
    print_info("Ok, gimme a sec while I figure this out.")
    # group all lines of a member by putting them in a dictionary
    dict = {}
    for line in lines:
        line_array = line.split(",")
        dict.setdefault(line_array[index], []).append(line)

    return dict



# Returns a number between 0 and 1. If such number was not provided through the
# percentage flag, the user is prompted for it
def get_percentage(args):
    percentage = 0

    #prompt user
    if not(args.percentage) or ( args.percentage > 1 or args.percentage < 0) :
        #get the percentage of user records that should be kept
        number = input("Aight, what percentage of users do you want to keep? [0-100] ")
        number = float(number)
        while not(type(number) == float and number <= 100 and number >= 0):
            number = input("Don't be a smartass! Gimme a number between 0 and 100! ")
            number = float(number)

        percentage =  number / 100

    else:
        percentage = args.percentage

    return percentage



# returns a set containing all the user id's in the file
def get_uids(args):
    #create a list with all user IDs
    print_info("Just lemme get all the peeps that are in here real quick.")
    users = []
    with open(args.file, "r") as read_file:
        reader = csv.reader(read_file, delimiter=args.delimiter)
        header = reader.__next__()
        #an error is raised here if incorrect delimiter was user_index
        try:
            uid_index = header.index("IKL")
        except:
            die("Couldn't find 'IKL' in the header. Sure you used the correct delimiter?")

        #process data lines
        previous_uid = ""
        for row in reader:
            uid = row[uid_index]

            if uid != previous_uid:
                users.append(uid)

            #save current uid for next row
            previous_uid = uid

    #make sure every user was only selected once
    return set(users)



# sort an array of arrays according to database
def sort_sequence_array(array, date_index):
    res = array

    for i in range(0, len(res)):
        for j in range(i, len(res)):
            format = "%Y-%m-%d %H:%M:%S"
            date1 = datetime.strptime(res[i][date_index], format)
            date2 = datetime.strptime(res[j][date_index], format)

            if date2 < date1:
                tmp = res[i]
                res[i] = res[j]
                res[j] = tmp

    return res



#transforms an array of arrays into an itemset string
def get_itemset(array, action_index):
    res = ""

    for line in array:
        res += line[action_index].replace(" ", "")
        res += " "

    return res



#transforms an array of arrays into an itemset string
def get_sequence(array, action_index):
    res = ""

    for line in array:
        res += line[action_index].replace(" ", "") #remove whitespace
        res += " -1 "

    #sequences are terminated by "-2"
    res += " -2"

    return res



# Searches for a file name to write the numbrify mappings to. It keeps looking
# until it found a file that doesn't exist yet.
def get_mappings_path():
    path = "mapping_"
    number = 0
    extension = ".txt"

    while os.path.isfile(path + str(number) + extension):
        number += 1

    return path + str(number) + extension



# check what arguments the user gave to Willy
def parse_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument("command", help="Tell Willy what to do.")
    parser.add_argument("file",
                        help="Tell Willy what file to do something with.")
    parser.add_argument("-o", "--output-file",
                        help="Tell Willy what file to write to.")
    parser.add_argument("-d", "--delimiter", default=",")
    parser.add_argument("-p", "--percentage", type=float)
    parser.add_argument("-s", "--sort",
                        help="sort the hash when creating sequences")
    parser.add_argument("-f", "--format",
                        help = "the format that sequencify should use (e.g 'itemset')")

    args = parser.parse_args()

    return args




################################################################################
## Command Functions
################################################################################

# the dropCrap command. It throws away all data fields except for "IKL",
# "TRACE_ID", "TIMESTAMP" and "TYPE_OMSCHRIJVING"
def drop_crap(args):
    #load data file
    print_info("I'm loading your file. Be patient, it's a lot of records and I don't know how to multithread.")

    #create a new file to write to
    path = get_output_path(args)

    #process data and print to new file
    with open(args.file, "r") as read_file:
        with open(path, "w") as write_file:
            reader = csv.reader(read_file, delimiter=args.delimiter)
            for row in reader:
                write_file.write(row[0] + "," + row[2] + "," + row[3] + ","
                                + row[4] + "\n")

    print_info("Yo dude, I put all that good stuff you asked for in " + path)



# the filter command. It asks how much % of all users in the database should be
# retained. It then selects users until that percentage is reached and writes
# their data to a new file.
def filter(args):
    #create a list with all user IDs
    users = list(get_uids(args))


    #let user decide what percentage of users to keep
    percentage = get_percentage(args)

    #select random users to print to new file
    selected_users = []
    while (len(selected_users) / len(users)) < percentage:
        #generate random user to be selected
        user_index = random.randint(0, len(users) - 1)
        selected_users.append(users.pop(user_index))

    print_info("Yo man, I selected " + str(len(selected_users)) +
                " dudes and dudettes for you, hope you're happy with them.")

    users = []  #free up some memory

    #use set for more efficient lookup
    selected_users = set(selected_users)


    #go over the file again to extract all data from selected users
    print_info("Let me see if I can find back all these peeps.")
    user_data = []
    with open(args.file, "r") as read_file:
        reader = csv.reader(read_file, delimiter=args.delimiter)
        header = reader.__next__()
        uid_index = header.index("IKL")
        for row in reader:
            if row[uid_index] in selected_users:
                user_data.append(row)


    #write all selected users to the output file
    print_info("About damn time, let the printing begin!")
    path = get_output_path(args, "filteredByWilly.csv")

    with open(path, "w") as write_file:
        #write the header line to the file
        write_file.write(",".join(header) + "\n")

        #write all the data to the file
        for row in user_data:
            write_file.write(",".join(row) + "\n")



# transform the data in a format that SPMF can read. Itemsets are separated
# just by spaces. In Sequences, itemsets are separated by "-1" and a sequence
# itself is terminated by "-2".
def sequencify(args):
    #check if the requested output format is a valid once
    available_formats = ("itemset", "sequence")

    if not args.format  or not args.format in available_formats:
        die("Invalid format, possible options are 'itemset' and 'sequence'")


    trace_hash = {}

    print_info("Putting all them sequences in a dictionary")
    # use a hash to group every trace's data
    with open(args.file, "r") as read_file:
        reader = csv.reader(read_file, delimiter=args.delimiter)
        header = reader.__next__()
        #an error is raised here if incorrect delimiter was user_index
        try:
            trace_index = header.index("TRACE_ID")
            action_index = header.index("TYPE_OMSCHRIJVING")
            timestamp_index = header.index("TIMESTAMP")
        except:
            die("Sure you used the correct delimiter?")

        for row in reader:
            trace_id = row[trace_index]
            #add row to correct place in hash
            trace_hash.setdefault(trace_id, []).append(row)


    #sort the arrays that are stored in the trace hash based on date
    if args.sort:
        print_inf("Starting to sort the traces. If you have to go to the toilet, now's the time.")
        for key in trace_hash:
            trace_hash[key] = sort_sequence_array(trace_hash[key], timestamp_index)

    #for every key in the hash, write out the sequence of actions
    path = get_output_path(args, "sequences.txt")
    with open(path, "w") as write_file:
        for key in trace_hash:
            line = ""

            #print itemset
            if args.format == "itemset":
                line = get_itemset(trace_hash[key], action_index)

            #print sequence
            elif args.format == "sequence":
                line = get_sequence(trace_hash[key], action_index)

            #append line to file
            write_file.write(line + "\n")



# Numbrify maps every value of the "TYPE_OMSCHRIJVING" field to a numeric value.
# It then uses that mapping to
def numbrify(args):
    mapping_dict = {}

    path = get_output_path(args, "numbrified.csv")

    #process data and print to new file
    print_info("Seems you want some numbrification done. Fine, I'll park it in " + path)
    with open(args.file, "r") as read_file:
        with open(path, "w") as write_file:
            reader = csv.reader(read_file, delimiter=args.delimiter)
            header = reader.__next__()
            #an error is raised here if incorrect delimiter was user_index
            try:
                action_index = header.index("TYPE_OMSCHRIJVING")
            except:
                die("Sure you used the correct delimiter?")

            #write header to new file
            write_file.write(",".join(header) + "\n")

            #process data
            for row in reader:
                if not (row[action_index] in mapping_dict.keys()):
                    mapping_dict[row[action_index]] = len(mapping_dict.keys()) + 1

                #replace string with number
                row[action_index] = str(mapping_dict[row[action_index]])

                #write new line
                write_file.write(",".join(row) + "\n")

    #print the mapping to a new file
    path = get_mappings_path()

    print_info("In case you want to check things, the mappings I made are in " + path)
    with open(path, "w") as write_file:
        for k in mapping_dict:
            write_file.write(k + "  =  " + str(mapping_dict[k]) + "\n")






################################################################################
## Program Start
################################################################################

if __name__ == "__main__":
    args = parse_arguments()


    # start the dropCrap command
    if args.command == "dropCrap":
        drop_crap(args)

    # start the filter command
    elif args.command == "filter":
        filter(args)

    #start the sequencify command
    elif args.command == "sequencify":
        sequencify(args)

    #start the numbrify
    elif args.command == "numbrify":
        numbrify(args)

    # execute this is the command was unknown
    else:
        die("Yo man, what is this '" + args.command +
                "' thing you're talking about? I don't know how to do that.")
